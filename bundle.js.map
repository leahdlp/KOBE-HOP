{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/game.js","webpack:///./src/index.js","webpack:///./src/level.js","webpack:///./src/player.js"],"names":["KobeHop","canvas","ctx","getContext","dimensions","width","height","registerEvents","restart","running","animate","player","jump","score","Player","level","Level","boundKeyStrokeHandler","keyStroke","bind","addEventListener","e","keyCode","play","movePlayer","collidesWith","bounds","outOfBounds","gameOver","alert","landedPlatform","console","log","drawScore","requestAnimationFrame","loc","x","y","font","fillStyle","fillText","strokeStyle","lineWidth","strokeText","document","canvasEle","getElementById","game","Game","CONSTANTS","GAP_HEIGHT","GAP_WIDTH","PLATFORM_HEIGHT","PLATFORM_WIDTH","EDGE_BUFFER","PLATFORM_SPACING","firstPlatformLocation","platforms","randomPlatform","location","heightRange","spaceRange","platform","left","right","top","bottom","landed","drawBackground","drawPlatforms","movePlatform","background","Image","src","onload","drawImage","callback","eachPlatform","PLATFORM_SPEED","shift","newX","platformss","newY","push","fillRect","Platform_WIDTH","forEach","_overlap","object","collision","GRAVITY","JUMP_SPEED","TERMINAL_VEL","PLAYER_WIDTH","PLAYER_HEIGHT","vel","dir","Math","abs","drawPlayer","belowTheBottom"],"mappings":"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A,WAAKnC,GAAL,CAASuC,WAAT,GAAuB,OAAvB;AACA,WAAKvC,GAAL,CAASwC,SAAT,GAAqB,CAArB;AACA,WAAKxC,GAAL,CAASyC,UAAT,CAAoB,KAAK9B,KAAzB,EAAgCsB,GAAG,CAACC,CAApC,EAAuCD,GAAG,CAACE,CAA3C;AACD;;;;;;;;;;;;;;;;;;ACzFH;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEAO,QAAQ,CAACxB,gBAAT,CAA0B,kBAA1B,EAA8C,YAAY;AACxD,MAAMyB,SAAS,GAAGD,QAAQ,CAACE,cAAT,CAAwB,aAAxB,CAAlB,CADwD,CAExD;AACA;AACA;;AACA,MAAMC,IAAI,GAAG,IAAIC,6CAAJ,CAASH,SAAT,CAAb,CALwD,CAMxD;;AACAd,SAAO,CAACC,GAAR,CAAYa,SAAZ;AACAd,SAAO,CAACC,GAAR,CACE,oBADF,EARwD,CAYxD;AACD,CAbD,E,CAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,I;;;;;;;;;;;;;;;;;;;;ACpVA,IAAMiB,SAAS,GAAG;AAClB;AACEC,YAAU,EAAE,GAFI;AAGhBC,WAAS,EAAE,EAHK;AAIhBC,iBAAe,EAAE,EAJD;AAKhBC,gBAAc,EAAE,EALA;AAMhBC,aAAW,EAAE,EANG;AAOhBC,kBAAgB,EAAE,CAAC,GAAD,EAAM,GAAN,CAPF,CAQlB;;AARkB,CAAlB;;IAWqBvC,K;AACnB,iBAAYZ,UAAZ,EAAwB;AAAA;;AACtB,SAAKA,UAAL,GAAkBA,UAAlB;AAEA,QAAMoD,qBAAqB,GAAG,CAC1B,KAAKpD,UAAL,CAAgBE,MAAhB,GAAyB,CADC,EAE1B,KAAKF,UAAL,CAAgBC,KAAhB,GAAwB,CAFE,CAA9B,CAHsB,CAOtB;;AAEA,SAAKoD,SAAL,GAAiB,CACf,KAAKC,cAAL,CAAoBF,qB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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","import Player from \"./player\";\nimport Level from \"./level\";\n\nexport default class KobeHop {\n  constructor(canvas) {\n    this.ctx = canvas.getContext(\"2d\");\n    this.dimensions = { width: canvas.width, height: canvas.height };\n    this.registerEvents();\n    this.restart();\n  }\n\n  play() {\n    this.running = true;\n    this.animate();\n    this.player.jump();\n  }\n\n  restart() {\n    this.running = false;\n    this.score = 0;\n    this.player = new Player(this.dimensions);\n    this.level = new Level(this.dimensions);\n\n    this.animate();\n  }\n\n  registerEvents() {\n    this.boundKeyStrokeHandler = this.keyStroke.bind(this);\n    this.ctx.canvas.addEventListener(\"keydown\", this.boundKeyStrokeHandler);\n  }\n\n  keyStroke(e) {\n    let keyCode = e.keyCode;\n\n    if (!this.running) this.play();\n\n    switch (keyCode) {\n      case 37:\n        this.player.movePlayer(\"left\");\n        break;\n      case 39:\n        this.player.movePlayer(\"right\")\n      default:\n        break;\n    }\n    // this.player.jump();\n  }\n\n  gameOver() {\n    return (\n      this.level.collidesWith(this.player.bounds()) ||\n      this.player.outOfBounds()\n    );\n  }\n\n  animate() {\n    this.level.animate(this.ctx);\n    this.player.animate(this.ctx);\n    //then we check to see if the game is over and let the player know\n    if (this.gameOver()) {\n      alert(this.score);\n      this.restart();\n    }\n\n    //we see if they have scored a point by passing a platform\n    this.level.landedPlatform(this.player.bounds(), () => {\n      this.score += 1;\n      console.log(this.score);\n    });\n\n    //and draw the score\n    this.drawScore();\n\n    //if the game is NOT running, we do not animate the next frame\n    if (this.running) {\n      //This calls this function again, after around 1/60th of a second\n      requestAnimationFrame(this.animate.bind(this));\n    }\n  }\n\n  drawScore() {\n    //loc will be the location\n    const loc = { x: ( 5 * this.dimensions.width) / 6, y: this.dimensions.height / 6 };\n    this.ctx.font = \"bold 50pt serif\";\n    this.ctx.fillStyle = \"white\";\n    this.ctx.fillText(this.score, loc.x, loc.y);\n    this.ctx.strokeStyle = \"black\";\n    this.ctx.lineWidth = 2;\n    this.ctx.strokeText(this.score, loc.x, loc.y);\n  }\n}\n","// const Game = require(\"./game\");\n// const GameView = require(\"./game_view\");\n// import Game from '../game';\n// import Player from \"../player\";\n// import MovingObject from \"./moving_object\"\n\nimport Game from './game';\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  const canvasEle = document.getElementById(\"game-canvas\");\n  // canvasEl.width = Game.DIM_X;\n  // canvasEl.height = Game.DIM_Y;\n  // const ctx = canvasEle.getContext(\"2d\");\n  const game = new Game(canvasEle);\n  // new GameView(game, ctx).start();\n  console.log(canvasEle)\n  console.log(\n    'webapck is working'\n  )\n\n  // window.MovingObject = MovingObject;\n});\n\n\n\n// class DoodleJump {\n//   constructor(canvas) {\n//     this.ctx = canvas.getContext(\"2d\");\n//     this.dimensions = { width: canvas.width, height: canvas.height };\n//     this.registerEvents();\n//     this.restart();\n//   }\n\n//   play() {\n//     this.running = true;\n//     this.animate();\n//     this.player.jump();\n//   }\n\n//   restart() {\n//     this.running = false;\n//     this.score = 0;\n//     this.player = new Player(this.dimensions);\n//     this.level = new Level(this.dimensions);\n\n//     this.animate();\n//   }\n\n//   registerEvents() {\n//     this.boundKeyStrokeHandler = this.keyStroke.bind(this);\n//     this.ctx.canvas.addEventListener(\"keydown\", this.boundKeyStrokeHandler);\n//   }\n\n//   keyStroke(e) {\n//     let keyCode = e.keyCode;\n\n//     if (!this.running) this.play();\n\n//     switch (keyCode) {\n//       case 37:\n//         this.player.movePlayer(\"left\");\n//         break;\n//       case 39:\n//         this.player.movePlayer(\"right\");\n//       default:\n//         break;\n//     }\n//     // this.player.jump();\n//   }\n\n//   gameOver() {\n//     return (\n//       this.level.collidesWith(this.player.bounds()) || this.player.outOfBounds()\n//     );\n//   }\n\n//   //this is the key method of gaming action\n//   //animate tells the game to advance one bit\n//   //the bird moves, the level moves\n//   //everything is redrawn to the screen\n//   animate() {\n//     //first we move and draw the level\n//     this.level.animate(this.ctx);\n//     //then we move and draw the bird\n//     this.player.animate(this.ctx);\n//     //then we check to see if the game is over and let the player know\n//     if (this.gameOver()) {\n//       alert(this.score);\n//       this.restart();\n//     }\n\n//     //we see if they have scored a point by passing a platform\n//     this.level.landedPlatform(this.player.bounds(), () => {\n//       this.score += 1;\n//       console.log(this.score);\n//     });\n\n//     //and draw the score\n//     this.drawScore();\n\n//     //if the game is NOT running, we do not animate the next frame\n//     if (this.running) {\n//       //This calls this function again, after around 1/60th of a second\n//       requestAnimationFrame(this.animate.bind(this));\n//     }\n//   }\n\n//   drawScore() {\n//     //loc will be the location\n//     const loc = {\n//       x: (5 * this.dimensions.width) / 6,\n//       y: this.dimensions.height / 6,\n//     };\n//     this.ctx.font = \"bold 50pt serif\";\n//     this.ctx.fillStyle = \"white\";\n//     this.ctx.fillText(this.score, loc.x, loc.y);\n//     this.ctx.strokeStyle = \"black\";\n//     this.ctx.lineWidth = 2;\n//     this.ctx.strokeText(this.score, loc.x, loc.y);\n//   }\n// }\n\n// const LEVEL_CONSTANTS = {\n//   //   PLATFORM_SPEED: 2,\n//   GAP_HEIGHT: 175,\n//   GAP_WIDTH: 60,\n//   PLATFORM_HEIGHT: 25,\n//   PLATFORM_WIDTH: 75,\n//   EDGE_BUFFER: 50,\n//   PLATFORM_SPACING: [100, 100],\n//   //   WARM_UP_SECONDS: 1,\n// };\n\n// class Level {\n//   constructor(dimensions) {\n//     this.dimensions = dimensions;\n\n//     const firstPlatformLocation = [\n//       this.dimensions.height / 5,\n//       this.dimensions.width / 3,\n//     ];\n//     //   LEVEL_CONSTANTS.WARM_UP_SECONDS * 60 * LEVEL_CONSTANTS.PLATFORM_SPEED;\n\n//     this.platforms = [\n//       this.randomPlatform(firstPlatformLocation),\n//       this.randomPlatform(\n//         firstPlatformLocation[0] + LEVEL_CONSTANTS.PLATFORM_SPACING,\n//         firstPlatformLocation[1] + LEVEL_CONSTANTS.PLATFORM_SPACING\n//       ),\n//       this.randomPlatform(\n//         firstPlatformLocation[0] + LEVEL_CONSTANTS.PLATFORM_SPACING * 2,\n//         firstPlatformLocation[1] + LEVEL_CONSTANTS.PLATFORM_SPACING * 2\n//       ),\n//     ];\n//   }\n\n//   randomPlatform(location) {\n//     const heightRange =\n//       this.dimensions.height - 2 * LEVEL_CONSTANTS.EDGE_BUFFER - LEVEL_CONSTANTS.GAP_HEIGHT;\n//     const spaceRange =\n//       this.dimensions.width - 2 * LEVEL_CONSTANTS.EDGE_BUFFER - LEVEL_CONSTANTS.GAP_WIDTH;\n//     // const gapTop = Math.random() * heightRange + LEVEL_CONSTANTS.EDGE_BUFFER;\n//     // const gapSide = Math.random() * widthRange + LEVEL_CONSTANTS.EDGE_BUFFER;\n//     const platform = {\n//       left: location[0],\n//       right: LEVEL_CONSTANTS.PLATFORM_WIDTH + location[0],\n//       top: location[1],\n//       bottom: LEVEL_CONSTANTS.PLATFORM_HEIGHT + location[1],\n//       landed: false,\n//     };\n//     return platform;\n//   }\n\n//   animate(ctx) {\n//     this.drawBackground(ctx);\n//     this.movePlatforms();\n//     this.drawPlatforms(ctx);\n//   }\n\n//   drawBackground(ctx) {\n//     let background = new Image();\n//     background.src =\n//       \"https://cdn3.vectorstock.com/i/1000x1000/15/12/background-of-basketball-court-vector-7441512.jpg\";\n//     background.onload = function () {\n//       ctx.drawImage(background, 0, 0);\n//     };\n//     // ctx.fillStyle = \"skyblue\";\n//     // ctx.fillRect(0, 0, this.dimensions.width, this.dimensions.height);\n//   }\n\n//   landedPlatform(player, callback) {\n//     this.eachPlatform((platform) => {\n//       if (platform.top < player.bottom) {\n//         if (!platform.landed) {\n//           platform.landed = true;\n//           callback();\n//         }\n//       }\n//     });\n//   }\n\n//   movePlatform() {\n//     this.eachPlatform(function (platform) {\n//       platform.top -= LEVEL_CONSTANTS.PLATFORM_SPEED;\n//       platform.bottom -= LEVEL_CONSTANTS.PLATFORM_SPEED;\n//     });\n\n//     //if a platform has left the screen add a new one to the end\n//     if (this.platforms[0].top <= 0) {\n//       this.platforms.shift();\n//       const newX = this.platformss[1].left + LEVEL_CONSTANTS.PLATFORM_SPACING;\n//       const newY = this.platforms[1].top + LEVEL_CONSTANTS.PLATFORM_SPACING;\n//       this.platforms.push(this.randomPlatform([newX, newY]));\n//     }\n//   }\n\n//   drawPlatforms(ctx) {\n//     this.eachPlatform(function (platform) {\n//       ctx.fillStyle = \"green\";\n\n//       //draw platform\n//       ctx.fillRect(\n//         platform.left,\n//         platform.top,\n//         LEVEL_CONSTANTS.Platform_WIDTH,\n//         platform.top - platform.bottom\n//       );\n//     });\n//   }\n\n//   eachPlatform(callback) {\n//     this.platforms.forEach(callback.bind(this));\n//   }\n//   //This method shall return true if the bird passed in is currently\n//   //colliding with any platform.\n//   collidesWith(player) {\n//     //this function returns true if the the rectangles overlap\n//     const _overlap = (platform, object) => {\n//       //check that they don't overlap in the x axis\n//       if (\n//         (object.left < platform.right && object.left > platform.left) ||\n//         (platform.right < object.right && platform.left < object.right)\n//       ) {\n//         if (object.bottom < platform.top) return true;\n//         return false;\n//       }\n//       //check that they don't overlap in the y axis\n//       //   if (objecttop > platform.bottom || objectbottom > platform.top) {\n//       //     return false;\n//       //   }\n//       //   return true;\n//     };\n//     let collision = false;\n//     this.eachPlatform((platform) => {\n//       //check if the bird is overlapping (colliding) with either platform\n//       if (_overlap(platform, player)) collision = true;\n//       // _overlap(platform.bottomPlatform, player)\n//     });\n//     return collision;\n//   }\n// }\n\n// const PLAYER_CONSTANTS = {\n//   GRAVITY: 0.4,\n//   JUMP_SPEED: 8,\n//   TERMINAL_VEL: 12,\n//   PLAYER_WIDTH: 40,\n//   PLAYER_HEIGHT: 30,\n// };\n\n// class Player {\n//   constructor(dimensions) {\n//     this.dimensions = dimensions;\n//     this.x = this.dimensions.width / 3;\n//     // this.y = this.dimensions.height / 2;\n//     this.y = 0;\n//     this.vel = 0;\n//   }\n\n//   jump() {\n//     //if this were a more realistic player simulation, we would be adding to the velocity\n//     //instead of just assigning it outright\n//     //to make the experience more fun and 'bouncy' we just set it directly\n//     this.vel = -1 * PLAYER_CONSTANTS.JUMP_SPEED;\n//   }\n\n//   movePlayer(dir = \"\") {\n//     if (dir === \"right\") {\n//       this.x += 10;\n//     } else if (dir === \"left\") {\n//       this.x -= 10;\n//     }\n//     //for each frame, the Player should move by it's current velocity\n//     //velocity is 'pixels per frame', so each frame it should update position by vel\n//     this.y += this.vel;\n//     //the acceleration of gravity is in pixels per second per second\n//     //so each second, it changes the velocity by whatever the gravity PLAYER_constant is\n//     this.vel += PLAYER_CONSTANTS.GRAVITY;\n//     //we set a 'terminal velocity', a maximum speed the Player can travel\n//     //this keeps the game from becoming too wild because the Player is moving too fast to control\n//     if (Math.abs(this.vel) > PLAYER_CONSTANTS.TERMINAL_VEL) {\n//       //if the terminal velocity is exceeded, we set it to the terminal velicty\n//       if (this.vel > 0) {\n//         this.vel = PLAYER_CONSTANTS.TERMINAL_VEL;\n//       } else {\n//         this.vel = PLAYER_CONSTANTS.TERMINAL_VEL * -1;\n//       }\n//     }\n//   }\n\n//   animate(ctx) {\n//     this.movePlayer();\n//     this.drawPlayer(ctx);\n//   }\n\n//   drawPlayer(ctx) {\n//     ctx.fillStyle = \"yellow\";\n//     ctx.fillRect(\n//       this.x,\n//       this.y,\n//       PLAYER_CONSTANTS.PLAYER_WIDTH,\n//       PLAYER_CONSTANTS.PLAYER_HEIGHT\n//     );\n//   }\n\n//   bounds() {\n//     return {\n//       left: this.x,\n//       right: this.x + PLAYER_CONSTANTS.PLAYER_WIDTH,\n//       top: this.y,\n//       bottom: this.y + PLAYER_CONSTANTS.PLAYER_HEIGHT,\n//     };\n//   }\n\n//   outOfBounds() {\n//     // const aboveTheTop = this.y < 0;\n//     const belowTheBottom =\n//       this.y + PLAYER_CONSTANTS.PLAYER_HEIGHT > this.dimensions.height;\n//     return belowTheBottom;\n//   }\n// }","const CONSTANTS = {\n//   PLATFORM_SPEED: 2,\n  GAP_HEIGHT: 175,\n  GAP_WIDTH: 60,\n  PLATFORM_HEIGHT: 25,\n  PLATFORM_WIDTH: 75,\n  EDGE_BUFFER: 50,\n  PLATFORM_SPACING: [100, 100],\n//   WARM_UP_SECONDS: 1,\n};\n\nexport default class Level {\n  constructor(dimensions) {\n    this.dimensions = dimensions;\n\n    const firstPlatformLocation = [\n        this.dimensions.height / 5,\n        this.dimensions.width / 3\n    ]\n    //   CONSTANTS.WARM_UP_SECONDS * 60 * CONSTANTS.PLATFORM_SPEED;\n\n    this.platforms = [\n      this.randomPlatform(firstPlatformLocation),\n      this.randomPlatform(\n        firstPlatformLocation[0] + CONSTANTS.PLATFORM_SPACING,\n        firstPlatformLocation[1] + CONSTANTS.PLATFORM_SPACING\n      ),\n      this.randomPlatform(\n        firstPlatformLocation[0] + CONSTANTS.PLATFORM_SPACING * 2,\n        firstPlatformLocation[1] + CONSTANTS.PLATFORM_SPACING * 2\n      ),\n    ];\n  }\n\n  randomPlatform(location) {\n    const heightRange =\n      this.dimensions.height - 2 * CONSTANTS.EDGE_BUFFER - CONSTANTS.GAP_HEIGHT;\n    const spaceRange =\n      this.dimensions.width - 2 * CONSTANTS.EDGE_BUFFER - CONSTANTS.GAP_WIDTH;\n    // const gapTop = Math.random() * heightRange + CONSTANTS.EDGE_BUFFER;\n    // const gapSide = Math.random() * widthRange + CONSTANTS.EDGE_BUFFER;\n    const platform = {\n        left: location[0],\n        right: CONSTANTS.PLATFORM_WIDTH + location[0],\n        top: location[1],\n        bottom: CONSTANTS.PLATFORM_HEIGHT + location[1],\n        landed: false,\n    };\n    return platform;\n  }\n\n  animate(ctx) {\n    this.drawBackground(ctx);\n    this.drawPlatforms(ctx);\n    this.movePlatform();\n  }\n\n  drawBackground(ctx) {\n      let background = new Image();\n      background.src =\n          \"https://cdn3.vectorstock.com/i/1000x1000/15/12/background-of-basketball-court-vector-7441512.jpg\";\n      background.onload = function() {\n          ctx.drawImage(background, -100, -110)\n      }\n    // ctx.fillStyle = \"skyblue\";\n    // ctx.fillRect(0, 0, this.dimensions.width, this.dimensions.height);\n  }\n\n  landedPlatform(player, callback) {\n    this.eachPlatform(platform => {\n      if (platform.top < player.bottom) {\n        if (!platform.landed) {\n          platform.landed = true;\n          callback();\n        }\n      }\n    });\n  }\n\n  movePlatform() {\n    this.eachPlatform(function (platform) {\n      platform.top -= CONSTANTS.PLATFORM_SPEED;\n      platform.bottom -= CONSTANTS.PLATFORM_SPEED;\n    });\n\n    //if a platform has left the screen add a new one to the end\n    if (this.platforms[0].top <= 0) {\n      this.platforms.shift();\n      const newX = this.platformss[1].left + CONSTANTS.PLATFORM_SPACING;\n      const newY = this.platforms[1].top + CONSTANTS.PLATFORM_SPACING;\n      this.platforms.push(this.randomPlatform([newX, newY]));\n    }\n  }\n\n  drawPlatforms(ctx) {\n    this.eachPlatform(function (platform) {\n      ctx.fillStyle = \"green\";\n\n      //draw platform\n      ctx.fillRect(\n        platform.left,\n        platform.top,\n        CONSTANTS.Platform_WIDTH,\n        platform.top - platform.bottom\n      );\n    });\n  }\n\n  eachPlatform(callback) {\n    this.platforms.forEach(callback.bind(this));\n  }\n  //This method shall return true if the bird passed in is currently\n  //colliding with any platform.\n  collidesWith(player) {\n    //this function returns true if the the rectangles overlap\n    const _overlap = (platform, object) => {\n      //check that they don't overlap in the x axis\n      if ((object.left < platform.right && object.left > platform.left) \n        || (platform.right < object.right && platform.left < object.right)) {\n\n        if (object.bottom < platform.top) return true;\n        return false;\n      }\n      //check that they don't overlap in the y axis\n    //   if (objecttop > platform.bottom || objectbottom > platform.top) {\n    //     return false;\n    //   }\n    //   return true;\n    };\n    let collision = false;\n    this.eachPlatform(platform => {\n        //check if the bird is overlapping (colliding) with either platform\n      if (_overlap(platform, player)) collision = true;\n        // _overlap(platform.bottomPlatform, player)\n    });\n    return collision;\n  }\n}\n\n","const CONSTANTS = {\n  GRAVITY: 0.4,\n  JUMP_SPEED: 8,\n  TERMINAL_VEL: 12,\n  PLAYER_WIDTH: 40,\n  PLAYER_HEIGHT: 30,\n};\n\nclass Player {\n  constructor(dimensions) {\n    this.dimensions = dimensions;\n    this.x = this.dimensions.width / 3;\n    // this.y = this.dimensions.height / 2;\n    this.y = 0;\n    this.vel = 0;\n  }\n\n  jump() {\n    //if this were a more realistic player simulation, we would be adding to the velocity\n    //instead of just assigning it outright\n    //to make the experience more fun and 'bouncy' we just set it directly\n    this.vel = -1 * CONSTANTS.JUMP_SPEED;\n  }\n\n  movePlayer(dir=\"\") {\n    if (dir === \"right\") {\n        this.x += 10\n    } else if (dir === \"left\") {\n        this.x -= 10\n    }\n    //for each frame, the Player should move by it's current velocity\n    //velocity is 'pixels per frame', so each frame it should update position by vel\n    this.y += this.vel;\n    //the acceleration of gravity is in pixels per second per second\n    //so each second, it changes the velocity by whatever the gravity constant is\n    this.vel += CONSTANTS.GRAVITY;\n    //we set a 'terminal velocity', a maximum speed the Player can travel\n    //this keeps the game from becoming too wild because the Player is moving too fast to control\n    if (Math.abs(this.vel) > CONSTANTS.TERMINAL_VEL) {\n      //if the terminal velocity is exceeded, we set it to the terminal velicty\n      if (this.vel > 0) {\n        this.vel = CONSTANTS.TERMINAL_VEL;\n      } else {\n        this.vel = CONSTANTS.TERMINAL_VEL * -1;\n      }\n    }\n  }\n\n  animate(ctx) {\n    this.movePlayer();\n    this.drawPlayer(ctx);\n  }\n\n  drawPlayer(ctx) {\n    ctx.fillStyle = \"yellow\";\n    ctx.fillRect(this.x, this.y, CONSTANTS.PLAYER_WIDTH, CONSTANTS.PLAYER_HEIGHT);\n  }\n\n  bounds() {\n    return {\n      left: this.x,\n      right: this.x + CONSTANTS.PLAYER_WIDTH,\n      top: this.y,\n      bottom: this.y + CONSTANTS.PLAYER_HEIGHT,\n    };\n  }\n\n  outOfBounds() {\n    // const aboveTheTop = this.y < 0;\n    const belowTheBottom =\n      this.y + CONSTANTS.PLAYER_HEIGHT > this.dimensions.height;\n    return belowTheBottom;\n  }\n}\n\nexport default Player;"],"sourceRoot":""}